<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Stock Market Trading Game</title>
  <style>
    /* General Styles */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #74ebd5, #ACB6E5);
      margin: 0;
      padding: 10px;
    }
    .container {
      max-width: 1000px; /* compact UI */
      margin: auto;
      background: #fff;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }
    h1, h2 {
      text-align: center;
      color: #333;
      margin: 5px 0;
    }
    #timer {
      font-size: 1.4em;
      text-align: center;
      margin-bottom: 5px;
      font-weight: bold;
    }
    #marketSentiment {
      text-align: center;
      font-size: 1.1em;
      margin-bottom: 5px;
      font-weight: bold;
      color: #3E2723;
    }
    #economicIndicators {
      text-align: center;
      font-size: 0.95em;
      margin-bottom: 10px;
      color: #424242;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    table, th, td {
      border: 1px solid #ddd;
    }
    th, td {
      padding: 5px;
      text-align: center;
    }
    /* Form Styles */
    #tradeForm {
      text-align: center;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    #tradeForm label, #tradeForm input, #tradeForm select, #tradeForm button {
      margin: 3px;
    }
    button {
      padding: 6px 10px;
      border: none;
      border-radius: 5px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      font-size: 0.9em;
    }
    button:hover {
      background-color: #45a049;
    }
    .max-btn {
      background-color: #2196F3;
    }
    #resetButton {
      background-color: #f44336;
    }
    /* Button colors for short selling */
    #shortSellButton {
      background-color: #FF9800;
    }
    #coverShortButton {
      background-color: #9C27B0;
    }
    /* Panels (Log, Ticker, Social Media, Achievements & Analytics) */
    #messageLog, #newsTicker, #socialMediaFeed, #achievementsPanel, #analyticsPanel {
      border: 1px solid #ddd;
      background: #fafafa;
      padding: 5px;
      height: 100px;
      overflow-y: auto;
      margin-bottom: 10px;
      font-size: 0.85em;
    }
    .disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    /* Chart Canvas */
    #chartContainer {
      text-align: center;
      margin-bottom: 10px;
    }
    #chartCanvas {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    /* Insider Tip */
    #insiderTipArea {
      border: 2px dashed #FF9800;
      background: #FFF3E0;
      padding: 5px;
      margin-bottom: 10px;
      text-align: center;
      font-weight: bold;
      color: #E65100;
      font-size: 0.9em;
    }
    /* Modal Styles (for settings and mini‑games) */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.5);
    }
    .modal-content {
      background-color: #fff;
      margin: 10% auto;
      padding: 10px;
      border: 1px solid #888;
      width: 80%;
      max-width: 600px;
      border-radius: 10px;
      font-size: 0.9em;
    }
    .close-modal {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }
    .close-modal:hover,
    .close-modal:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }
    /* Settings Button */
    #settingsButton {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: #9C27B0;
      padding: 5px 8px;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Stock Market Trading Game</h1>
    <div id="timer">Time Remaining: 15:00</div>
    <div id="marketSentiment">Market Sentiment: Neutral</div>
    <div id="economicIndicators">Economic Indicators: Inflation: 2.0%, GDP Growth: 3.0%, Unemployment: 5.0%</div>
    
    <h2>Market</h2>
    <table id="marketTable">
      <thead>
        <tr>
          <th>Commodity</th>
          <th>Price</th>
          <th>Available Shares</th>
        </tr>
      </thead>
      <tbody>
        <!-- Market data generated by JavaScript -->
      </tbody>
    </table>
    
    <h2>Your Portfolio</h2>
    <div id="portfolio">
      <p>Cash: $<span id="cashDisplay">5000.00</span></p>
      <div id="holdings">
        <!-- Holdings (with profit and liquidation price) will be listed here -->
      </div>
    </div>
    
    <h2>Trade</h2>
    <div id="insiderTipArea" style="display:none;"></div>
    <form id="tradeForm">
      <label for="commoditySelect">Commodity:</label>
      <select id="commoditySelect"></select>
      
      <label for="quantityInput">Quantity:</label>
      <input type="number" id="quantityInput" min="1" value="1">
      
      <button type="button" id="maxBuyButton" class="max-btn">Max Buy</button>
      <button type="button" id="maxSellButton" class="max-btn">Max Sell</button>
      
      <label for="leverageSelect">Leverage:</label>
      <select id="leverageSelect">
        <option value="1">1× (Normal)</option>
        <option value="2">2× (Margin Trading)</option>
        <option value="3">3× (High Leverage)</option>
        <option value="4">4× (Extreme Leverage)</option>
      </select>
      
      <button type="button" id="buyButton">Buy</button>
      <button type="button" id="sellButton">Sell</button>
      <button type="button" id="sellAllButton" style="background-color:#f44336;">Sell All</button>
      <button type="button" id="shortSellButton" class="max-btn">Short Sell</button>
      <button type="button" id="coverShortButton" class="max-btn">Cover Short</button>
      <button type="button" id="autoAdvisorButton" class="max-btn">Auto Advisor</button>
    </form>
    
    <h2>Price History Chart</h2>
    <div id="chartContainer">
      <canvas id="chartCanvas" width="800" height="200"></canvas>
    </div>
    
    <h2>Game Log</h2>
    <div id="messageLog"></div>
    
    <h2>News Ticker</h2>
    <div id="newsTicker"></div>
    
    <h2>Social Media Trends</h2>
    <div id="socialMediaFeed"></div>
    
    <h2>Achievements</h2>
    <div id="achievementsPanel"></div>
    
    <h2>Analytics</h2>
    <div id="analyticsPanel"></div>
    
    <div style="text-align: center; margin-top: 10px;">
      <button type="button" id="resetButton">Reset Game</button>
    </div>
  </div>
  
  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <span class="close-modal" id="closeSettings">&times;</span>
      <h2>Game Settings</h2>
      <label><input type="checkbox" id="toggleNews" checked> Show News Ticker</label><br>
      <label><input type="checkbox" id="toggleInsider" checked> Enable Insider Tips</label><br>
      <label><input type="checkbox" id="toggleAudio" checked> Enable Audio</label><br>
      <button type="button" id="saveSettings">Save Settings</button>
    </div>
  </div>
  
  <!-- Summary Modal -->
  <div id="summaryModal" class="modal">
    <div class="modal-content">
      <h2>Game Over Summary</h2>
      <p id="finalScore"></p>
      <h3>Achievements Unlocked:</h3>
      <ul id="finalAchievements"></ul>
      <button type="button" id="closeSummary">Close</button>
    </div>
  </div>
  
  <!-- New Mini-Game Modals -->
  
  <!-- Flash Trade Challenge Modal -->
  <div id="flashTradeModal" class="modal">
    <div class="modal-content">
      <span class="close-modal" id="closeFlashTrade">&times;</span>
      <h2>Flash Trade Challenge</h2>
      <p id="flashTradeMsg">Click the button within <span id="flashTradeTimer">10</span> seconds to win a bonus!</p>
      <button id="flashTradeButton">Trade Now!</button>
    </div>
  </div>
  
  <!-- Pattern Recognition Puzzle Modal -->
  <div id="patternPuzzleModal" class="modal">
    <div class="modal-content">
      <span class="close-modal" id="closePatternPuzzle">&times;</span>
      <h2>Pattern Recognition Puzzle</h2>
      <p id="patternSequence"></p>
      <p>Will the next value be <strong>Higher</strong> or <strong>Lower</strong>?</p>
      <button id="patternHigher">Higher</button>
      <button id="patternLower">Lower</button>
    </div>
  </div>
  
  <!-- Reaction Mini-Game Modal -->
  <div id="reactionModal" class="modal">
    <div class="modal-content">
      <span class="close-modal" id="closeReaction">&times;</span>
      <h2>Reaction Challenge</h2>
      <p>Get ready...</p>
      <button id="reactionButton" style="display:none;">Click Me!</button>
      <p id="reactionTimer"></p>
    </div>
  </div>
  
  <!-- Settings Button -->
  <button id="settingsButton">Settings</button>
  
  <!-- Audio Elements -->
  <audio id="tradeSound" src="https://www.soundjay.com/buttons/sounds/button-16.mp3"></audio>
  <audio id="achievementSound" src="https://www.soundjay.com/buttons/sounds/button-3.mp3"></audio>
  
  <script>
    /* ========================= Global Variables & Data ========================= */
    let gameTime = 15 * 60; // 15 minutes in seconds
    let cash = 5000; // Starting with $5,000
    let portfolio = {}; // key: commodity name, value: { shares, cashInvested, marginLoan, entryPrice, leverage }
    let tradeHistory = [];
    let gameInterval, priceInterval, bankEventInterval, newsEventInterval, insiderTipInterval;
    let dividendInterval, sentimentInterval, splitInterval, flashCrashInterval, marketRallyInterval;
    let socialMediaInterval, globalEventInterval, earningsInterval, economicInterval, analyticsInterval;
    // New intervals for mini‑games:
    let flashTradeInterval, patternPuzzleInterval, reactionInterval;
    
    let settings = { newsTicker: true, insiderTips: true, audio: true };
    
    // Achievements tracking
    let achievements = {
      firstTrade: { unlocked: false, description: "Completed your first trade!" },
      bigProfit: { unlocked: false, description: "Made a profit of over $500 in a trade!" },
      diversified: { unlocked: false, description: "Held positions in 2 or more commodities!" },
      marginMaster: { unlocked: false, description: "Used margin trading (leveraged positions)!" },
      bigSpender: { unlocked: false, description: "Invested over $5000 in a single trade!" },
      insidersFavor: { unlocked: false, description: "Acted on an insider tip!" }
    };
    
    // Price history for charting
    let priceHistory = {};
    
    // Current Insider Tip
    let currentInsiderTip = null;
    
    // Commodities (Bitcoin/Ethereum removed)
    let commodities = [
      { name: "Lumber",      price: 50,   available: 150, volatilityMultiplier: 2.0 },
      { name: "Oil",         price: 100,  available: 150, volatilityMultiplier: 2.0 },
      { name: "Gold",        price: 1500, available: 150, volatilityMultiplier: 2.0 },
      { name: "Electronics", price: 200,  available: 150, volatilityMultiplier: 2.0 },
      { name: "Rice",        price: 20,   available: 150, volatilityMultiplier: 2.0 },
      { name: "Coffee",      price: 10,   available: 150, volatilityMultiplier: 2.0 }
    ];
    
    commodities.forEach(c => { priceHistory[c.name] = [c.price]; });
    
    /* ========================= Utility Functions ========================= */
    function formatTime(seconds) {
      let m = Math.floor(seconds / 60), s = seconds % 60;
      return (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
    }
    
    function logMessage(msg) {
      let logDiv = document.getElementById("messageLog");
      let p = document.createElement("p");
      p.innerText = msg;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
      if(settings.audio) document.getElementById("tradeSound").play();
    }
    
    function logNews(msg) {
      if(!settings.newsTicker) return;
      let newsDiv = document.getElementById("newsTicker");
      let p = document.createElement("p");
      p.innerText = msg;
      newsDiv.appendChild(p);
      newsDiv.scrollTop = newsDiv.scrollHeight;
    }
    
    function logSocialMedia(msg) {
      let smDiv = document.getElementById("socialMediaFeed");
      let p = document.createElement("p");
      p.innerText = msg;
      smDiv.appendChild(p);
      smDiv.scrollTop = smDiv.scrollHeight;
    }
    
    function updateAchievementsDisplay() {
      let achDiv = document.getElementById("achievementsPanel");
      achDiv.innerHTML = "";
      for(let key in achievements) {
        if(achievements[key].unlocked) {
          let p = document.createElement("p");
          p.innerText = achievements[key].description;
          achDiv.appendChild(p);
        }
      }
    }
    
    function unlockAchievement(key) {
      if(!achievements[key].unlocked) {
        achievements[key].unlocked = true;
        logMessage("Achievement Unlocked: " + achievements[key].description);
        updateAchievementsDisplay();
        if(settings.audio) document.getElementById("achievementSound").play();
      }
    }
    
    /* ========================= Display Update Functions ========================= */
    function updateTimer() {
      document.getElementById("timer").innerText = "Time Remaining: " + formatTime(gameTime);
    }
    
    function updateMarketTable() {
      let tbody = document.querySelector("#marketTable tbody");
      tbody.innerHTML = "";
      commodities.forEach(c => {
        let row = document.createElement("tr");
        let nameCell = document.createElement("td"); nameCell.innerText = c.name;
        let priceCell = document.createElement("td"); priceCell.innerText = "$" + c.price.toFixed(2);
        let availCell = document.createElement("td"); availCell.innerText = c.available;
        row.appendChild(nameCell); row.appendChild(priceCell); row.appendChild(availCell);
        tbody.appendChild(row);
      });
    }
    
    // Update portfolio display to show profit and liquidation price if leveraged.
    function updatePortfolioDisplay() {
      document.getElementById("cashDisplay").innerText = cash.toFixed(2);
      let holdingsDiv = document.getElementById("holdings");
      holdingsDiv.innerHTML = "";
      for(let key in portfolio) {
        let pos = portfolio[key];
        let c = commodities.find(x => x.name === key);
        let currentPrice = c ? c.price : 0;
        let holdingValue = pos.shares * currentPrice;
        let netValue = holdingValue - pos.marginLoan;
        // Compute profit:
        let profit;
        if(pos.shares >= 0) {
          profit = (currentPrice * pos.shares - pos.marginLoan) - pos.cashInvested;
        } else {
          profit = pos.cashInvested - (currentPrice * Math.abs(pos.shares));
        }
        // Compute liquidation price if leverage > 1 (for long positions, and symmetric for shorts)
        let liquidationPrice = "";
        if(pos.leverage && pos.leverage > 1) {
          if(pos.shares > 0) {
            let liq = pos.entryPrice * (1 - (pos.leverage - 1) * 0.25);
            liquidationPrice = liq.toFixed(2);
          } else {
            let liq = pos.entryPrice * (1 + (pos.leverage - 1) * 0.25);
            liquidationPrice = liq.toFixed(2);
          }
        }
        let div = document.createElement("div");
        div.innerText = `${key} (${(pos.shares >= 0 ? "Long" : "Short")}): ${pos.shares} shares, Value: $${holdingValue.toFixed(2)} (Net: $${netValue.toFixed(2)}), Profit: $${profit.toFixed(2)}` +
                       (liquidationPrice ? `, Liquidation: $${liquidationPrice}` : "");
        holdingsDiv.appendChild(div);
      }
    }
    
    // Update the price history chart and add axis labels.
    function updateChart() {
      let canvas = document.getElementById("chartCanvas");
      let ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let selectedCommodity = document.getElementById("commoditySelect").value;
      let history = priceHistory[selectedCommodity];
      if(!history || history.length < 2) return;
      let minPrice = Math.min(...history);
      let maxPrice = Math.max(...history);
      let range = maxPrice - minPrice;
      if(range === 0) range = 1;
      
      // Draw price line
      ctx.beginPath();
      for(let i = 0; i < history.length; i++) {
        let x = (i / (history.length - 1)) * canvas.width;
        let y = canvas.height - ((history[i] - minPrice) / range) * canvas.height;
        if(i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "#FF5722";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw vertical axis labels
      ctx.font = "10px Arial";
      ctx.fillStyle = "black";
      ctx.fillText(minPrice.toFixed(2), 2, canvas.height - 2);
      ctx.fillText(maxPrice.toFixed(2), 2, 12);
      // Draw horizontal axis labels (start and end indices)
      ctx.fillText("0", 5, canvas.height - 5);
      ctx.fillText((history.length - 1).toString(), canvas.width - 20, canvas.height - 5);
    }
    
    function updateAnalytics() {
      let portfolioValue = calculatePortfolioValue();
      let profit = portfolioValue - 5000;
      let roi = (profit / 5000) * 100;
      let analyticsDiv = document.getElementById("analyticsPanel");
      analyticsDiv.innerHTML = `<p>Total Portfolio Value: $${portfolioValue.toFixed(2)}</p>
                                 <p>Total Profit: $${profit.toFixed(2)}</p>
                                 <p>ROI: ${roi.toFixed(2)}%</p>
                                 <p>Total Trades: ${tradeHistory.length}</p>`;
    }
    
    /* ========================= Price & Market Mechanics ========================= */
    function updatePrices() {
      // Use a larger base fluctuation for more volatility.
      let baseChange = (Math.random() - 0.5) * 0.03;
      commodities.forEach(c => {
        let change = baseChange * c.volatilityMultiplier;
        c.price *= (1 + change);
        if(c.price < 0.1) c.price = 0.1;
        priceHistory[c.name].push(c.price);
        if(priceHistory[c.name].length > 100) { priceHistory[c.name].shift(); }
      });
      updateMarketTable();
      updatePortfolioDisplay();
      updateChart();
    }
    
    function triggerBankEvent() {
      if(Math.random() < 0.1) {
        let c = commodities[Math.floor(Math.random() * commodities.length)];
        let add = Math.random() < 0.5;
        let changeAmount = Math.floor(Math.random() * 20) + 1;
        if(add) { c.available += changeAmount; logMessage(`Bank event: Released ${changeAmount} additional shares of ${c.name}`); }
        else { if(c.available >= changeAmount) { c.available -= changeAmount; logMessage(`Bank event: Removed ${changeAmount} shares of ${c.name} from the market`); } }
        updateMarketTable();
      }
    }
    
    function triggerNewsEvent() {
      let c = commodities[Math.floor(Math.random() * commodities.length)];
      let events = ["a sudden surge in demand for", "supply disruptions in", "new regulations impacting", "unexpected surplus in", "market speculation around"];
      let eventText = events[Math.floor(Math.random() * events.length)];
      let newsMsg = `Breaking News: ${eventText} ${c.name}! Volatility increased temporarily.`;
      logMessage(newsMsg);
      logNews(newsMsg);
      let original = c.volatilityMultiplier;
      c.volatilityMultiplier = 4;
      setTimeout(() => { c.volatilityMultiplier = original; logMessage(`News Update: Market stabilizing for ${c.name}.`); logNews(`News Update: Market stabilizing for ${c.name}.`); }, 10000);
    }
    
    function triggerSocialMediaTrend() {
      let trends = ["#BuyTheDip", "#SellOff", "#MarketMadness", "#TechBoom", "#EcoInvest", "#AgriSurge"];
      let trend = trends[Math.floor(Math.random() * trends.length)];
      logSocialMedia(`Social Media Trend: ${trend}`);
    }
    
    function triggerGlobalEvent() {
      let events = ["an international trade dispute", "a global pandemic update", "a major geopolitical conflict", "a surprising diplomatic breakthrough"];
      let event = events[Math.floor(Math.random() * events.length)];
      let msg = `Global Event: ${event} is affecting markets! Increased volatility for 10 seconds.`;
      logMessage(msg);
      logNews(msg);
      commodities.forEach(c => { c.volatilityMultiplier *= 1.5; });
      setTimeout(() => { commodities.forEach(c => { c.volatilityMultiplier /= 1.5; }); logMessage("Global Event Update: Markets stabilizing after global event."); }, 10000);
    }
    
    function updateEconomicIndicators() {
      let inflation = (Math.random() * 2 + 1).toFixed(1);
      let gdp = (Math.random() * 3 + 2).toFixed(1);
      let unemployment = (Math.random() * 3 + 4).toFixed(1);
      document.getElementById("economicIndicators").innerText = `Economic Indicators: Inflation: ${inflation}%, GDP Growth: ${gdp}%, Unemployment: ${unemployment}%`;
    }
    
    function triggerEarningsReport() {
      let c = commodities[Math.floor(Math.random() * commodities.length)];
      let reportTypes = ["better-than-expected earnings", "missed earnings estimates", "announced a new product line", "revealed a major expansion plan"];
      let report = reportTypes[Math.floor(Math.random() * reportTypes.length)];
      let msg = `Earnings Report: ${c.name} ${report}! Volatility increased for 10 seconds.`;
      logMessage(msg);
      logNews(msg);
      let original = c.volatilityMultiplier;
      c.volatilityMultiplier *= 2;
      setTimeout(() => { c.volatilityMultiplier = original; logMessage(`Earnings Update: ${c.name} volatility normalizing.`); }, 10000);
    }
    
    function triggerDividendEvent() {
      let c = commodities[Math.floor(Math.random() * commodities.length)];
      let yieldPct = (Math.random() * 0.01 + 0.005).toFixed(3);
      if(portfolio[c.name] && portfolio[c.name].shares > 0) {
        let dividend = portfolio[c.name].shares * c.price * yieldPct;
        cash += dividend;
        logMessage(`Dividend: ${c.name} paid a dividend of $${dividend.toFixed(2)} (${(yieldPct * 100).toFixed(1)}% yield).`);
        updatePortfolioDisplay();
      } else {
        logMessage(`Dividend: ${c.name} paid a dividend, but you hold no shares.`);
      }
    }
    
    function triggerStockSplit() {
      if(Math.random() < 0.05) {
        let eligible = commodities.filter(c => c.price > 100);
        if(eligible.length > 0) {
          let c = eligible[Math.floor(Math.random() * eligible.length)];
          c.available *= 2;
          c.price /= 2;
          if(portfolio[c.name]) { portfolio[c.name].shares *= 2; }
          logMessage(`Stock Split: ${c.name} has split! Prices halved and shares doubled.`);
          updateMarketTable();
          updatePortfolioDisplay();
        }
      }
    }
    
    function triggerFlashCrash() {
      if(Math.random() < 0.03) {
        logMessage("Flash Crash: Market prices are plummeting!");
        commodities.forEach(c => {
          c.price *= 0.7;
          priceHistory[c.name].push(c.price);
          if(priceHistory[c.name].length > 100) { priceHistory[c.name].shift(); }
        });
        updateMarketTable();
        updateChart();
        setTimeout(() => { logMessage("Flash Crash: Market is recovering..."); }, 10000);
      }
    }
    
    function triggerMarketRally() {
      if(Math.random() < 0.03) {
        logMessage("Market Rally: Prices are surging!");
        commodities.forEach(c => {
          c.price *= 1.3;
          priceHistory[c.name].push(c.price);
          if(priceHistory[c.name].length > 100) { priceHistory[c.name].shift(); }
        });
        updateMarketTable();
        updateChart();
        setTimeout(() => { logMessage("Market Rally: Rally subsiding."); }, 10000);
      }
    }
    
    function calculatePortfolioValue() {
      let total = cash;
      for(let key in portfolio) {
        let c = commodities.find(x => x.name === key);
        if(c) { total += portfolio[key].shares * c.price - portfolio[key].marginLoan; }
      }
      return total;
    }
    
    function endGame() {
      clearInterval(gameInterval);
      clearInterval(priceInterval);
      clearInterval(bankEventInterval);
      clearInterval(newsEventInterval);
      clearInterval(insiderTipInterval);
      clearInterval(dividendInterval);
      clearInterval(sentimentInterval);
      clearInterval(splitInterval);
      clearInterval(flashCrashInterval);
      clearInterval(marketRallyInterval);
      clearInterval(socialMediaInterval);
      clearInterval(globalEventInterval);
      clearInterval(earningsInterval);
      clearInterval(economicInterval);
      clearInterval(analyticsInterval);
      clearInterval(flashTradeInterval);
      clearInterval(patternPuzzleInterval);
      clearInterval(reactionInterval);
      document.getElementById("tradeForm").classList.add("disabled");
      logMessage("Game over! Final portfolio value: $" + calculatePortfolioValue().toFixed(2));
      showSummaryModal();
    }
    
    /* ========================= Trade Handlers ========================= */
    function sellPosition(commodityName, quantity) {
      if(!portfolio[commodityName]) { alert("No position in " + commodityName); return; }
      let pos = portfolio[commodityName];
      if(quantity <= 0 || Math.abs(quantity) > Math.abs(pos.shares)) { alert(`Invalid quantity. You hold ${pos.shares} shares.`); return; }
      let c = commodities.find(x => x.name === commodityName);
      let currentPrice = c.price;
      let saleProceeds = currentPrice * quantity;
      let fraction = quantity / Math.abs(pos.shares);
      let cashInvestedToSell = pos.cashInvested * fraction;
      let marginLoanToSell = pos.marginLoan * fraction;
      let profit = saleProceeds - (cashInvestedToSell + marginLoanToSell);
      if(pos.shares > 0) {
        cash += saleProceeds - marginLoanToSell;
      } else {
        cash -= saleProceeds - marginLoanToSell;
        profit = -profit;
      }
      pos.shares = pos.shares > 0 ? pos.shares - quantity : pos.shares + quantity;
      pos.cashInvested -= cashInvestedToSell;
      pos.marginLoan -= marginLoanToSell;
      c.available += quantity;
      logMessage(`Sold ${quantity} shares of ${commodityName} at $${currentPrice.toFixed(2)}. Profit: $${profit.toFixed(2)}`);
      if(profit > 500 && !achievements.bigProfit.unlocked) { unlockAchievement("bigProfit"); }
      if(Object.keys(portfolio).length >= 2 && !achievements.diversified.unlocked) { unlockAchievement("diversified"); }
      if(pos.shares === 0) { delete portfolio[commodityName]; }
      updateMarketTable();
      updatePortfolioDisplay();
      tradeHistory.push({ type: "Sell", commodity: commodityName, quantity: quantity, price: currentPrice, profit: profit });
    }
    
    document.getElementById("buyButton").addEventListener("click", function() {
      let commodityName = document.getElementById("commoditySelect").value;
      let quantity = parseInt(document.getElementById("quantityInput").value);
      let leverage = parseInt(document.getElementById("leverageSelect").value);
      if(quantity <= 0) { alert("Quantity must be > 0"); return; }
      if(portfolio[commodityName] && portfolio[commodityName].shares > 0) { alert("Already have a long position in " + commodityName); return; }
      let c = commodities.find(x => x.name === commodityName);
      if(c.available < quantity) { alert("Not enough shares available."); return; }
      let currentPrice = c.price;
      let totalValue = currentPrice * quantity;
      let cashRequired = totalValue / leverage;
      if(cash < cashRequired) { alert(`Insufficient funds. Need $${cashRequired.toFixed(2)}.`); return; }
      cash -= cashRequired;
      c.available -= quantity;
      let marginLoan = (leverage > 1) ? (totalValue - cashRequired) : 0;
      portfolio[commodityName] = { shares: quantity, cashInvested: cashRequired, marginLoan: marginLoan, entryPrice: currentPrice, leverage: leverage };
      logMessage(`Bought ${quantity} shares of ${commodityName} at $${currentPrice.toFixed(2)} with ${leverage}× leverage.`);
      if(currentInsiderTip && currentInsiderTip.commodity === commodityName && Date.now() < currentInsiderTip.expires) { unlockAchievement("insidersFavor"); }
      if(!achievements.firstTrade.unlocked) { unlockAchievement("firstTrade"); }
      if(leverage > 1 && !achievements.marginMaster.unlocked) { unlockAchievement("marginMaster"); }
      if(totalValue >= 5000 && !achievements.bigSpender.unlocked) { unlockAchievement("bigSpender"); }
      updateMarketTable();
      updatePortfolioDisplay();
      tradeHistory.push({ type: "Buy", commodity: commodityName, quantity: quantity, price: currentPrice });
    });
    
    document.getElementById("sellButton").addEventListener("click", function() {
      let commodityName = document.getElementById("commoditySelect").value;
      let quantity = parseInt(document.getElementById("quantityInput").value);
      sellPosition(commodityName, quantity);
    });
    
    document.getElementById("sellAllButton").addEventListener("click", function() {
      let positions = Object.keys(portfolio);
      if(positions.length === 0) { alert("No positions to sell!"); return; }
      positions.forEach(function(commodityName) {
        let shares = Math.abs(portfolio[commodityName].shares);
        sellPosition(commodityName, shares);
      });
    });
    
    document.getElementById("maxBuyButton").addEventListener("click", function() {
      let commodityName = document.getElementById("commoditySelect").value;
      let leverage = parseInt(document.getElementById("leverageSelect").value);
      let c = commodities.find(x => x.name === commodityName);
      if(!c) { alert("Commodity not found."); return; }
      let maxQty = Math.floor((cash * leverage) / c.price);
      maxQty = Math.min(maxQty, c.available);
      if(maxQty <= 0) { alert("Cannot buy any shares."); return; }
      document.getElementById("quantityInput").value = maxQty;
    });
    
    document.getElementById("maxSellButton").addEventListener("click", function() {
      let commodityName = document.getElementById("commoditySelect").value;
      if(!portfolio[commodityName]) { alert("No position in " + commodityName); return; }
      document.getElementById("quantityInput").value = Math.abs(portfolio[commodityName].shares);
    });
    
    document.getElementById("shortSellButton").addEventListener("click", function() {
      let commodityName = document.getElementById("commoditySelect").value;
      let quantity = parseInt(document.getElementById("quantityInput").value);
      if(quantity <= 0) { alert("Quantity must be > 0"); return; }
      if(portfolio[commodityName] && portfolio[commodityName].shares < 0) { alert("Already have a short position in " + commodityName); return; }
      let c = commodities.find(x => x.name === commodityName);
      if(c.available < quantity) { alert("Not enough shares available to short."); return; }
      let currentPrice = c.price;
      cash += currentPrice * quantity;
      c.available -= quantity;
      portfolio[commodityName] = { shares: -quantity, cashInvested: currentPrice * quantity, marginLoan: 0, entryPrice: currentPrice };
      logMessage(`Short sold ${quantity} shares of ${commodityName} at $${currentPrice.toFixed(2)}.`);
      updateMarketTable();
      updatePortfolioDisplay();
      tradeHistory.push({ type: "Short Sell", commodity: commodityName, quantity: quantity, price: currentPrice });
    });
    
    document.getElementById("coverShortButton").addEventListener("click", function() {
      let commodityName = document.getElementById("commoditySelect").value;
      if(!portfolio[commodityName] || portfolio[commodityName].shares >= 0) { alert("No short position in " + commodityName); return; }
      let quantity = parseInt(document.getElementById("quantityInput").value);
      if(quantity <= 0 || quantity > Math.abs(portfolio[commodityName].shares)) { alert("Invalid quantity."); return; }
      let c = commodities.find(x => x.name === commodityName);
      let currentPrice = c.price;
      let cost = currentPrice * quantity;
      if(cash < cost) { alert("Insufficient funds to cover short."); return; }
      cash -= cost;
      c.available += quantity;
      let pos = portfolio[commodityName];
      let fraction = quantity / Math.abs(pos.shares);
      pos.shares += quantity;
      pos.cashInvested -= pos.cashInvested * fraction;
      logMessage(`Covered short of ${quantity} shares of ${commodityName} at $${currentPrice.toFixed(2)}.`);
      if(pos.shares === 0) { delete portfolio[commodityName]; }
      updateMarketTable();
      updatePortfolioDisplay();
      tradeHistory.push({ type: "Cover Short", commodity: commodityName, quantity: quantity, price: currentPrice });
    });
    
    document.getElementById("autoAdvisorButton").addEventListener("click", function() {
      let commodityName = document.getElementById("commoditySelect").value;
      let c = commodities.find(x => x.name === commodityName);
      if(!c) { alert("Commodity not found."); return; }
      let history = priceHistory[commodityName];
      let avg = history.reduce((acc, val) => acc + val, 0) / history.length;
      let currentPrice = c.price;
      if(currentPrice < avg * 0.98) {
        let leverage = parseInt(document.getElementById("leverageSelect").value);
        let maxQty = Math.floor((cash * leverage) / currentPrice);
        maxQty = Math.min(maxQty, c.available);
        document.getElementById("quantityInput").value = maxQty;
        logMessage(`Auto Advisor: ${commodityName} is undervalued. Recommendation: Buy ${maxQty} shares.`);
      } else if(currentPrice > avg * 1.02) {
        if(portfolio[commodityName] && portfolio[commodityName].shares > 0) {
          document.getElementById("quantityInput").value = portfolio[commodityName].shares;
          logMessage(`Auto Advisor: ${commodityName} is overvalued. Recommendation: Sell all holdings.`);
        } else {
          logMessage(`Auto Advisor: ${commodityName} is overvalued, but no holdings exist.`);
        }
      } else {
        logMessage(`Auto Advisor: ${commodityName} is trading near its average. Consider holding.`);
      }
    });
    
    /* ========================= New Mini-Game Features ========================= */
    
    // A. Flash Trade Challenge
    function triggerFlashTradeChallenge() {
      let modal = document.getElementById("flashTradeModal");
      let timerSpan = document.getElementById("flashTradeTimer");
      let button = document.getElementById("flashTradeButton");
      modal.style.display = "block";
      let timeLeft = 10;
      timerSpan.innerText = timeLeft;
      let countdown = setInterval(() => {
        timeLeft--;
        timerSpan.innerText = timeLeft;
        if(timeLeft <= 0) {
          clearInterval(countdown);
          modal.style.display = "none";
        }
      }, 1000);
      button.onclick = function() {
        clearInterval(countdown);
        cash += 500; // Bonus reward
        logMessage("Flash Trade Challenge succeeded! Bonus $500 awarded.");
        updatePortfolioDisplay();
        modal.style.display = "none";
      };
      document.getElementById("closeFlashTrade").onclick = function() {
        clearInterval(countdown);
        modal.style.display = "none";
      };
    }
    
    // B. Pattern Recognition Puzzle
    function triggerPatternRecognitionPuzzle() {
      let modal = document.getElementById("patternPuzzleModal");
      let sequenceP = document.getElementById("patternSequence");
      modal.style.display = "block";
      // Generate a sequence of 5 random numbers between 50 and 150
      let sequence = [];
      for(let i = 0; i < 5; i++) {
        sequence.push(Math.floor(Math.random() * 100) + 50);
      }
      sequenceP.innerText = "Sequence: " + sequence.join(", ");
      // Determine the next number with a random delta between -10 and +10
      let delta = Math.floor(Math.random() * 21) - 10;
      let nextNumber = sequence[sequence.length - 1] + delta;
      let correctAnswer = nextNumber > sequence[sequence.length - 1] ? "Higher" : "Lower";
      
      document.getElementById("patternHigher").onclick = function() {
        if(correctAnswer === "Higher") {
          cash += 300;
          logMessage("Pattern Puzzle Correct! Bonus $300 awarded.");
        } else {
          logMessage("Pattern Puzzle Incorrect.");
        }
        modal.style.display = "none";
        updatePortfolioDisplay();
      };
      document.getElementById("patternLower").onclick = function() {
        if(correctAnswer === "Lower") {
          cash += 300;
          logMessage("Pattern Puzzle Correct! Bonus $300 awarded.");
        } else {
          logMessage("Pattern Puzzle Incorrect.");
        }
        modal.style.display = "none";
        updatePortfolioDisplay();
      };
      document.getElementById("closePatternPuzzle").onclick = function() {
        modal.style.display = "none";
      };
    }
    
    // D. Reaction Mini-Game
    function triggerReactionMiniGame() {
      let modal = document.getElementById("reactionModal");
      let reactionButton = document.getElementById("reactionButton");
      let reactionTimerP = document.getElementById("reactionTimer");
      modal.style.display = "block";
      reactionButton.style.display = "none";
      reactionTimerP.innerText = "";
      
      // After a random delay between 1 and 3 seconds, show the button.
      let delay = Math.floor(Math.random() * 2000) + 1000;
      setTimeout(() => {
        reactionButton.style.display = "block";
        let startTime = Date.now();
        reactionButton.onclick = function() {
          let reactionTime = Date.now() - startTime;
          reactionTimerP.innerText = "Your reaction time: " + reactionTime + " ms";
          if(reactionTime < 500) {
            cash += 200;
            logMessage("Reaction Challenge: Great reaction! Bonus $200 awarded.");
          } else {
            logMessage("Reaction Challenge: Too slow!");
          }
          setTimeout(() => { modal.style.display = "none"; updatePortfolioDisplay(); }, 2000);
        };
      }, delay);
      
      document.getElementById("closeReaction").onclick = function() {
        modal.style.display = "none";
      };
    }
    
    /* ========================= Settings & Modal Handlers ========================= */
    document.getElementById("settingsButton").addEventListener("click", function() {
      document.getElementById("settingsModal").style.display = "block";
    });
    document.getElementById("closeSettings").addEventListener("click", function() {
      document.getElementById("settingsModal").style.display = "none";
    });
    document.getElementById("saveSettings").addEventListener("click", function() {
      settings.newsTicker = document.getElementById("toggleNews").checked;
      settings.insiderTips = document.getElementById("toggleInsider").checked;
      settings.audio = document.getElementById("toggleAudio").checked;
      document.getElementById("settingsModal").style.display = "none";
      logMessage("Settings updated.");
    });
    document.getElementById("closeSummary").addEventListener("click", function() {
      document.getElementById("summaryModal").style.display = "none";
    });
    
    function showSummaryModal() {
      document.getElementById("finalScore").innerText = "Final Portfolio Value: $" + calculatePortfolioValue().toFixed(2);
      let finalAch = document.getElementById("finalAchievements");
      finalAch.innerHTML = "";
      for(let key in achievements) {
        if(achievements[key].unlocked) {
          let li = document.createElement("li");
          li.innerText = achievements[key].description;
          finalAch.appendChild(li);
        }
      }
      document.getElementById("summaryModal").style.display = "block";
    }
    
    /* ========================= Initialization & Intervals ========================= */
    function populateCommodityDropdown() {
      let select = document.getElementById("commoditySelect");
      select.innerHTML = "";
      commodities.forEach(c => {
        let option = document.createElement("option");
        option.value = c.name;
        option.innerText = c.name;
        select.appendChild(option);
      });
    }
    
    function initGame() {
      populateCommodityDropdown();
      updateMarketTable();
      updatePortfolioDisplay();
      updateTimer();
      updateChart();
      
      // Core intervals
      priceInterval = setInterval(updatePrices, 2000);
      bankEventInterval = setInterval(triggerBankEvent, 1000);
      newsEventInterval = setInterval(triggerNewsEvent, 20000);
      insiderTipInterval = setInterval(triggerInsiderTip, 30000);
      dividendInterval = setInterval(triggerDividendEvent, 45000);
      sentimentInterval = setInterval(() => { updateMarketSentiment(); }, 15000);
      splitInterval = setInterval(triggerStockSplit, 60000);
      flashCrashInterval = setInterval(triggerFlashCrash, 30000);
      marketRallyInterval = setInterval(triggerMarketRally, 30000);
      socialMediaInterval = setInterval(triggerSocialMediaTrend, 30000);
      globalEventInterval = setInterval(triggerGlobalEvent, 45000);
      earningsInterval = setInterval(triggerEarningsReport, 60000);
      economicInterval = setInterval(updateEconomicIndicators, 60000);
      analyticsInterval = setInterval(updateAnalytics, 5000);
      
      // New mini-game intervals
      flashTradeInterval = setInterval(triggerFlashTradeChallenge, 120000);      // every 2 minutes
      patternPuzzleInterval = setInterval(triggerPatternRecognitionPuzzle, 150000); // every 2.5 minutes
      reactionInterval = setInterval(triggerReactionMiniGame, 180000);            // every 3 minutes
      
      gameInterval = setInterval(function(){
        gameTime--;
        updateTimer();
        if(gameTime <= 0) { endGame(); }
      }, 1000);
    }
    
    function updateMarketSentiment() {
      let sentiments = ["Bullish", "Bearish", "Neutral"];
      let chosen = sentiments[Math.floor(Math.random() * sentiments.length)];
      document.getElementById("marketSentiment").innerText = "Market Sentiment: " + chosen;
      if(chosen === "Bullish") {
        commodities.forEach(c => { c.volatilityMultiplier *= 0.8; });
        setTimeout(() => { commodities.forEach(c => { c.volatilityMultiplier /= 0.8; }); logMessage("Bullish sentiment easing."); }, 10000);
      } else if(chosen === "Bearish") {
        commodities.forEach(c => { c.volatilityMultiplier *= 1.2; });
        setTimeout(() => { commodities.forEach(c => { c.volatilityMultiplier /= 1.2; }); logMessage("Bearish sentiment easing."); }, 10000);
      }
    }
    
    function triggerInsiderTip() {
      if(!settings.insiderTips) return;
      let c = commodities[Math.floor(Math.random() * commodities.length)];
      currentInsiderTip = { commodity: c.name, expires: Date.now() + 10000 };
      let tipMsg = `Insider Tip: Expect a spike in ${c.name} in the next 10 seconds!`;
      document.getElementById("insiderTipArea").style.display = "block";
      document.getElementById("insiderTipArea").innerText = tipMsg;
      logMessage(tipMsg);
      setTimeout(() => { currentInsiderTip = null; document.getElementById("insiderTipArea").style.display = "none"; }, 10000);
    }
    
    window.onload = initGame;
  </script>
</body>
</html>
